#region Copyright (c) 2009 S. van Deursen
/* The CuttingEdge.Conditions library enables developers to validate pre- and postconditions in a fluent 
 * manner.
 * 
 * To contact me, please visit my blog at http://www.cuttingedge.it/blogs/steven/ 
 *
 * Copyright (c) 2009 S. van Deursen
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies or substantial
 * portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
 * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
 * EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
#endregion

using System;
using System.Globalization;

namespace Ramone.Utility.Validation
{
  internal static class Throw
  {
    internal static void ValueShouldNotBeNull<T>(ConditionValidator<T> validator, string conditionDescription)
    {
      string condition = GetFormattedConditionMessage(validator, SR.ValueShouldNotBeNull,
          conditionDescription, validator.ArgumentName);

      validator.ThrowException(condition);
    }


    internal static void ValueShouldNotBeNullOrAnEmptyString(ConditionValidator<string> validator,
        string conditionDescription)
    {
      string condition = GetFormattedConditionMessage(validator, SR.StringShouldNotBeNullOrEmpty,
          conditionDescription, validator.ArgumentName);

      validator.ThrowException(condition);
    }


    private static string GetFormattedConditionMessage<T>(
      ConditionValidator<T> validator, 
      string resourceKey,
      string conditionDescription, params object[] resourceFormatArguments)
    {
      if (conditionDescription != null)
      {
        return FormatConditionDescription(validator, conditionDescription);
      }
      else
      {
        return SR.GetString(resourceKey, resourceFormatArguments);
      }
    }


    private static string FormatConditionDescription<T>(ConditionValidator<T> validator,
        string conditionDescription)
    {
      try
      {
        return String.Format(CultureInfo.CurrentCulture, conditionDescription ?? String.Empty,
            validator.ArgumentName);
      }
      catch (FormatException)
      {
        // We catch a FormatException. This code should only throw exceptions generated by the
        // validator.BuildException method. Throwing another exception would confuse the user and
        // would make debugging harder. When the user supplied an unformattable description, we simply
        // use the unformatted description as condition.
        return conditionDescription;
      }
    }
  }
}
